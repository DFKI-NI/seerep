{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"data-protection-notice/","title":"Data Protection Notice","text":"<p>The German Research Center for Artificial Intelligence (Deutsches Forschungszentrum f\u00fcr K\u00fcnstliche Intelligenz GmbH (DFKI)) and its staff are committed to goal- and risk-oriented information privacy and the fundamental right to the protection of personal data. In this data protection policy we inform you about the processing of your personal data when visiting and using our web site.</p>"},{"location":"data-protection-notice/#controller","title":"Controller","text":"<p>Deutsches Forschungszentrum f\u00fcr K\u00fcnstliche Intelligenz GmbH (DFKI) Phone: +49 631 20575 0 info@dfki.de Legal Notice</p>"},{"location":"data-protection-notice/#data-protection-officer","title":"Data protection officer","text":"<p>Phone: +49 631 20575 0 datenschutz@dfki.de</p>"},{"location":"data-protection-notice/#hosting-server","title":"Hosting Server","text":"<p>This website is hosted with Github. For more information about github's data processing and contacts, please refer to the Privacy Policy.</p>"},{"location":"data-protection-notice/#access-and-intervention","title":"Access and Intervention","text":"<p>Besides the information in this data protection policy you have the right of access to your personal data. To ensure fair data processing, you have the following rights:</p> <ul> <li>The right to rectification and completion of your personal data</li> <li>The right to erasure of your personal data</li> <li>The right to restriction of the processing of your personal data</li> <li>The right to object to the processing of your personal data on grounds related to your particular situation</li> </ul> <p>To exercise these rights, please contact our data protection officer.</p>"},{"location":"data-protection-notice/#right-to-lodge-a-complaint","title":"Right to lodge a complaint","text":"<p>You have the right to lodge a complaint with a supervisory authority if you consider that the processing of your personal data infringes statutory data protection regulations.</p>"},{"location":"legal-notice/","title":"LEGAL NOTICE","text":""},{"location":"legal-notice/#responsible-service-provider","title":"Responsible service provider","text":"<p>Responsible for the content of the domain agri-gaia.github.io/seerep from the point of view of \u00a7 5 TMG:</p> <p>Deutsches Forschungszentrum f\u00fcr K\u00fcnstliche Intelligenz GmbH (DFKI) Management: Prof. Dr. Antonio Kr\u00fcger Helmut Ditzer Trippstadter Str. 122 67663 Kaiserslautern Germany</p> <p>Phone: +49 631 20575 0 Email: info@dfki.de</p> <p>Register Court: Amtsgericht Kaiserslautern Register Number: HRB 2313</p> <p>ID-Number: DE 148 646 973</p> <p>The person responsible for the editorial content of the domain agri-gaia.github.io/seerep of the German Research Center for Artificial Intelligence GmbH within the meaning of \u00a7 18 para. 2 MStV is:</p> <p>Mark Niemeyer Berghoffstra\u00dfe 11 49090 Osnabr\u00fcck Germany</p> <p>Phone: +49 541 386050 2254 E-mail: mark.niemeyer@dfki.de Website URL:"},{"location":"legal-notice/#liability-for-content","title":"Liability for content","text":"<p>As a service provider, Deutsches Forschungszentrum f\u00fcr K\u00fcnstliche Intelligenz GmbH (DFKI) is responsible under general law for its own content published on this website in accordance with Section 7 para. 1 of the German Telemedia Act (TMG).</p> <p>DFKI makes every effort to keep the information on our website accurate and current, nevertheless, errors and uncertainties cannot be entirely ruled out. For this reason, DFKI undertakes no liability for ensuring that the provided information is current, accurate or complete, and is not responsible for its quality. DFKI is not liable for material or immaterial damages caused directly or indirectly by the use or non-use of the offered information, or by the use of erroneous and incomplete information, unless willful or grossly negligent fault can be demonstrated. This also applies with respect to software or data provided for download.</p> <p>DFKI reserves the right to modify, expand or delete parts of the website or the entire website without separate announcement, or to cease publication temporarily or definitively.</p>"},{"location":"legal-notice/#liability-for-links","title":"Liability for links","text":"<p>Pursuant to Section 7 para. 1 of TMG (German Tele-Media Act), the law limits our responsibility as a service provider to our own content on this website. According to Sections 8 \u2013 10 TMG, we are not obliged to permanently monitor any transmitted or stored third-party information, nor to investigate circumstances that might indicate illegal activity. This does not affect our obligation to remove or block information according to general law. However, we can only assume liability for such data from the point in time at which a concrete legal infringement has been identified. Upon notification of any such legal infringement, we will immediately delete the infringing content.</p> <p>Cross-references (\u201clinks\u201d) to the content providers are to be distinguished from our own content. Our offer includes links to external third-party websites. Providers or operators of linked external pages are always responsible for their respective content. We cannot assume any liability for the content of the linked pages. This third-party content was checked by DFKI when the links were first set up to determine whether any legal infringements existed. At the time of the check, no legal infringements were apparent. However, it cannot be ruled out that the content is subsequently changed by the respective providers. A permanent control of the content of the linked pages is not reasonable without evidence of a legal infringement. Should you believe that the linked external pages infringe applicable law or otherwise contain inappropriate content, please notify us directly at: info@dfki.de.</p> <p>In case DFKI should notice or receive any indication that an external offer to which it has linked might cause civil or criminal liability, DFKI will immediately delete this link.</p>"},{"location":"legal-notice/#copyright","title":"Copyright","text":"<p>The layout of the homepage, the graphics used and other content on the DFKI website are protected by copyright. The reproduction, processing, distribution and any type of use outside the boundaries of copyright law require the prior written approval of the DFKI. Insofar as any content on this page was not created by DFKI, the copyrights of third parties will be respected. If you believe that you discovered a copyright infringement, please report this to us accordingly. Upon becoming aware of any legal infringements, DFKI will remove or disable access to such infringing content immediately.</p>"},{"location":"getting-started/client/pypi/","title":"SEEREP gRPC API","text":"<p>For easy communication to the server via Python the needed Python files for the gRPC API are available on pypi in the seerep-grpc project. Install them with:</p> <pre><code>pip install seerep-grpc\n</code></pre>"},{"location":"getting-started/client/pypi/#usage","title":"Usage","text":"<p>Import the classes from the <code>seerep.pb</code> or <code>seerep.fb</code> modules like this:</p> <pre><code>from seerep.pb import image_pb2 as image\nfrom seerep.pb import image_service_pb2_grpc as imageService\n</code></pre> <pre><code>from seerep.fb import Image\nfrom seerep.fb import image_service_grpc_fb as imageService\n</code></pre> <p>For more advanved examples take a look at the Tutorial or at the SEEREP repository.</p>"},{"location":"getting-started/server/configuration/","title":"Configure the server","text":"<p>When starting the server some options to configure the server are available. The configuration is possible via the command line, via a config file or via environment variables.</p>"},{"location":"getting-started/server/configuration/#command-line","title":"Command line","text":"<p>For the command line the following options are available. All of them are optional and have default values. The latest list of options can always be retrieved by starting the server with the <code>--help</code> argument.</p> <pre><code>Generic options:\n  -v [ --version ]                      print version string\n  --help                                produce help message\n  -c [ --config ] arg                   name of a file of a configuration.\n\nConfiguration:\n  -D [ --data-folder ] arg (=/seerep/devel/bin)\n                                        data folder\n  -L [ --log-path ] arg                 log path\n  --log-level arg (=info)               log-level [trace, debug, info, warning,\n                                        error, fatal]\n  -p [ --port ] arg (=9090)             gRPC port\n</code></pre>"},{"location":"getting-started/server/configuration/#config-file","title":"Config file","text":"<p>The configuration options of the command line options can also be set via a config file. The path and name of the config file has to be given to the server using the <code>--config</code> option.</p> <p>An example config file:</p> <pre><code>data-folder = /seerep/seerep-data/ #defaulting to work dir\nlog-path = /seerep/seerep-data/log/ #file logging disabled if not set\nlog-level = info\nport = 9090\n</code></pre>"},{"location":"getting-started/server/configuration/#environment-variables","title":"Environment Variables","text":"<p>If one of the following environment variables is set, it will be parsed and set as the command line equivalent.</p> Environment variable command line equivalent SEEREP_DATA_FOLDER --data-folder SEEREP_LOG_PATH --log-path SEEREP_LOG_LEVEL --log-level SEEREP_PORT --port"},{"location":"getting-started/server/docs/","title":"Docs","text":"<p>The documentation is published via GitHub Pages. The responsible workflow builds <code>Doxygen</code> and <code>MkDocs</code> and publishes them on the <code>gh-pages</code> branch. MkDocs focusses on higher level concepts like the installation process and a package overview, while Doxygen is used for code documentation. If you want to work on the documentation locally i.e for a PR follow the steps below.</p>"},{"location":"getting-started/server/docs/#dependencies","title":"Dependencies","text":"<p>If you are not using the SEEREP development container, you need to have <code>doxygen</code> and <code>MkDocs-Material</code> installed, use the commands below:</p> <pre><code>pip3 mkdocs-material\nsudo apt install doxygen\n</code></pre>"},{"location":"getting-started/server/docs/#mkdocs","title":"MkDocs","text":"<p>To run MkDocs locally switch into the main directory of SEEREP, where the <code>mkdocs.yml</code> is located. Then use <code>mkdocs serve</code> to build and deploy MkDocs on a local http-server. The page should then be available under http://127.0.0.1:8000/.</p>"},{"location":"getting-started/server/docs/#doxygen","title":"Doxygen","text":"<p>To create the Doxygen output locally switch into the main directory of SEEREP, where the <code>Doxyfile</code> is located and run <code>doxygen Doxyfile</code>. Now an <code>doxygen/html/</code> folder should be in the same directory, switch into it.</p> <p>If you are not working in the development container you can simply open the <code>index.html</code> with your browser of choice (e.g. <code>firefox index.html</code>). Otherwise, use <code>python3 -m http.server</code> to start a local web server which serves the content. The page should be available under the default http://0.0.0.0:8000/ address.</p> <p>If you want to run MkDocs and Doxygen at the same time you need to provide a different port to the Doxygen http-server, use <code>python3 -m http.server 8002</code> instead.</p>"},{"location":"getting-started/server/installationDev/","title":"Development Environment Installation","text":"<p>This page provides an overview on how to install the SEEREP development environment.</p>"},{"location":"getting-started/server/installationDev/#vs-code-development-container","title":"VS-Code Development Container","text":"<ul> <li>The VS-Code Development Container is the easiest and recommended way to develop   SEEREP.</li> </ul>"},{"location":"getting-started/server/installationDev/#requirements","title":"Requirements","text":"<ul> <li>Current Version of VS-Code</li> <li>Docker &gt;= 17.12.0</li> </ul>"},{"location":"getting-started/server/installationDev/#development-container-setup","title":"Development Container Setup","text":"<ol> <li> <p>Clone the SEEREP repository from    Github and open it in VS-Code.</p> <pre><code>git clone https://github.com/agri-gaia/seerep\ncd seerep/\ncode .\n</code></pre> </li> <li> <p>Create a sibling folder next to the repo called <code>seerep-data</code>. This folder    will be mounted for the data exchange between host and container. Without    this folder, the following steps will fail!</p> <pre><code>mkdir ../seerep-data\n</code></pre> </li> <li> <p>Install the Remote    Containers    and    Docker    VS-Code extension with the following commands or via the extensions tab in Vs-Code.</p> <pre><code>code --install-extension ms-vscode-remote.remote-containers\ncode --install-extension ms-azuretools.vscode-docker\n</code></pre> </li> <li> <p>Press <code>F1</code> or <code>CTRL + SHIFT + P</code> in VS-Code and enter <code>Remote-Containers:    Reopen Folder in Container</code>. The installation process can take a couple of    minutes since, the docker image of SEEREP is downloaded and started.    Additionally, all necessary VS Code extensions are installed inside the    container and Intellisense, pre-commit hooks are    set up.VS-Code may ask you to login to GitHub, to get the latest    updates from the repository.</p> </li> </ol>"},{"location":"getting-started/server/installationDev/#credentials","title":"Credentials","text":"<p>The default username and password for the Docker container are:</p> <ul> <li>user:<code>docker</code></li> <li>password: <code>docker</code>.</li> </ul>"},{"location":"getting-started/server/installationDev/#pre-commit-checks","title":"Pre Commit Checks","text":"<p>This repository uses pre-commit checks to identify simple issues in the code base. The checks are automatically run before each commit. If you want to run the pre-commit checks during the development of a commit, use <code>pre-commit run -a</code>.</p>"},{"location":"getting-started/server/installationDev/#hints-to-fix-errors","title":"Hints To Fix Errors","text":"<p>If the setup or the <code>Remote-Containers: Reopen Folder in Container</code> fails, here are a couple of hints on how to fix them.</p> <ol> <li> <p>First make sure that the Docker container is not already running, use <code>docker    container stop $VSC_SEEREP_CONTAINER_ID</code>, the container ID can be found using    <code>docker ps</code>.</p> </li> <li> <p>Additionally, you can delete all the data regarding SEEREP, to get a fresh    installation:</p> <pre><code>docker volume rm seerep-vscode-extensions\ndocker volume rm vscode\ndocker rmi ghcr.io/agri-gaia/seerep_base:latest\n(docker rmi ghcr.io/agri-gaia/seerep_server:latest)\ndocker rmi vsc-seerep-*\n</code></pre> </li> </ol>"},{"location":"getting-started/server/installationDev/#manual-installation","title":"Manual Installation","text":"<p>It is not recommended to install the following dependencies globally. Some of them are really hard to uninstall. If you still want to install SEEREP in this way, follow the steps:</p> <ol> <li>Install ROS Noetic with the official    documentation</li> <li>Install SEEREPs dependencies:    gRPC, Protocol    Buffers,    Flatbuffers,    HighFive.    Therefore, please follow the steps in the base    Dockerfile.</li> </ol> <p>In order to build SEEREP, we recommend the common build tool from ROS, catkin. Follow the next steps to download and build seerep globally on your system.</p> <pre><code>source /opt/ros/noetic/setup.bash\nmkdir -p seerep_ws/src\ncd seerep_ws/src\ngit clone https://github.com/agri-gaia/seerep.git\ncd ..\ncatkin build\n</code></pre>"},{"location":"getting-started/server/kubernetes-deployment/","title":"Kubernetes Deployment","text":"<p>Besides, the local installation and the usage of an available docker container (see installation), one can also deploy the seerep-server within a kubernetes cluster.</p>"},{"location":"getting-started/server/kubernetes-deployment/#relevant-files","title":"Relevant files","text":"<p>Seerep can either be installed with the latest development state or the latest stable version. The relevant files can be found under</p> <ul> <li>/docker/kustomize/base --&gt; development</li> <li>/docker/kustomize/overlays/production --&gt; latest stable release</li> </ul> <p>The base-folder contains all yaml-files for a cluster deployments. This includes</p> <ul> <li>Deployment</li> <li>PersistentVolume and PersistentVolumeClaim</li> <li>Service</li> <li>Ingress</li> <li>Configuration</li> </ul> <p>The yaml-file for the cluster is create via Kustomize, hence this folder also contains a kustomization.yaml which puts everything together.</p> <p>The /overlay/production folder contains a second kustomization.yaml. Within this file everything needed to install a production system is overridden. This means, that the sealed secret is replaced with a new one, while the base secret is deleted. Further, the labels and the names of PV and PVC are changed to create new storage explicitly for the production system. Finally, the used image is replaced with the latest stable release.</p> <p>The usage of an overlay, thereby, follows the principles of Kustomize.</p>"},{"location":"getting-started/server/kubernetes-deployment/#building-with-kustomize","title":"Building with Kustomize","text":"<p>Before one can build the kubernetes manifest, one needs to install Kustomize (Kustomize installation) The easiest way to that is the download the latest binary from the offical release page</p> <p>To install the base-version of seerep either one can run:</p> <pre><code>kustomize build base/ &gt; seerep-deployment.yaml\n</code></pre> <p>to store the manifest in a separate yaml file. Or directly use kubectl:</p> <pre><code>kubectl apply -k base/\n</code></pre> <p>In order to install the production version, the commands look slightly different:</p> <pre><code>kustomize build overlays/production/ &gt; seerep-deployment.yaml\n</code></pre> <pre><code>kubectl apply -k overlays/production/\n</code></pre> <p>If someone has a running ArgoCD instance, it is also possible to integrate seerep as a project into ArgoCD.</p>"},{"location":"getting-started/server/kubernetes-deployment/#sealed-secrets","title":"Sealed Secrets","text":"<p>The certificates used for the secured ingress are created as sealed-secret. Hence, the secret can safely be stored in a repository. The sealed secret controller installed within the cluster will take care of unsealing the secret and make it usable. To combine Kustomize and sealed secrets this blogs-post was followed faun.pub</p>"},{"location":"getting-started/server/local-deployment/","title":"Local Deployment","text":"<p>The local deployment is based on the seerep_server docker image. The image with the latest (unstable) version can be pulled with the following command. It is recommended to use a version tag instead of <code>latest</code>.</p> <pre><code>docker pull ghcr.io/agri-gaia/seerep_server:latest\n</code></pre>"},{"location":"getting-started/server/local-deployment/#docker-run","title":"docker run","text":"<p>Run the following command to start the server using <code>docker run</code>. It is recommended to use a version tag instead of <code>latest</code>.</p> <pre><code>docker run \\\n  --volume=seerep-data:/mnt/seerep-data \\\n  --publish=9090:9090 \\\n  --name=seerep_server \\\n  --tty \\\n  ghcr.io/agri-gaia/seerep_server:latest \\\n  --data-folder=/mnt/seerep-data\n</code></pre>"},{"location":"getting-started/server/local-deployment/#docker-compose","title":"docker-compose","text":"<p>Run <code>docker-compose up</code> in the folder of the docker-compose.yml to start the server. It is recommended to use a version tag instead of <code>latest</code>.</p> <p>For this docker compose has to be installed. In the latest version <code>docker compose</code> without a hyphen as part of the Docker CLI replaces <code>docker-compose</code>.</p> <p>Example docker-compose.yml:</p> <pre><code>version: \"3.6\"\nservices:\n  seerep:\n    image: ghcr.io/agri-gaia/seerep_server:latest\n    tty: true\n    container_name: seerep_server\n    ports:\n      # the gRPC port\n      - 9090:9090\n    volumes:\n      # persist the data folder\n      - seerep-data:/mnt/seerep-data #using docker volume\n      #- /your/local/absolute/path:/mnt/seerep-data #using host folder\n    environment:\n      - TZ=Europe/Berlin\n      - SEEREP_DATA_FOLDER=/mnt/seerep-data\n      - SEEREP_LOG_PATH=/mnt/seerep-data/log\n      - SEEREP_LOG_LEVEL=info\nvolumes:\n  seerep-data:\n</code></pre>"},{"location":"getting-started/server/tests/","title":"Tests","text":"<p>SEEREP uses GoogleTest for C++ Unit Tests and pytest for integration tests. Unit tests are placed into the individual ROS packages while the intregation tests are setup in the <code>/tests</code> directory. The tests run automatically as a GitHub Action with every push.</p>"},{"location":"getting-started/server/tests/#c-unit-tests","title":"C++ Unit Tests","text":"<p>Currently tests are set up for:</p> <ul> <li>Flatbuffer ROS Conversions:     Functions for converting ROS message to Flatbuffers message and vice versa.</li> <li>HDF5 PB Image Interface     : Reading and writing of ProtoBuf Image messages to HDF5.</li> <li>HDF5 FB Image Interface     : Reading and writing of Flatbuffer Image messages to HDF5.</li> </ul>"},{"location":"getting-started/server/tests/#using-catkin","title":"Using catkin","text":"<p>To run the tests with <code>catkin</code> use:</p> <pre><code>catkin test # run all availabe tests\ncatkin test &lt;specific-package&gt; # test a specific package\n</code></pre>"},{"location":"getting-started/server/tests/#python-integration-tests","title":"Python Integration Tests","text":"<p>The integration tests cover most of the send and receive operations of SEEREP via Python. They use the Python examples as a base.</p>"},{"location":"getting-started/server/tests/#using-pytest","title":"Using pytest","text":"<p>To run all integration tests use:</p> <pre><code>pytest\n</code></pre> <p>in source directory <code>/seerep/src/</code>.</p> <p>To execute a subset of the integration tests:</p> <pre><code># Recursively executes all tests in the meta directory\npytest tests/python/gRPC/meta\n\n# Same execution as above\ncd tests/python/gRPC/meta\npytest\n\n# Run all tests specified in this file\npytest tests/python/gRPC/meta/test_gRPC_pb_projectCreation.py\n</code></pre>"},{"location":"getting-started/server/tests/#testing-through-vscode","title":"Testing through VSCode","text":"<p>Another way to run the tests is via the VSCode Testing Tab ( icon)</p> <p>If you have a fresh installation of the project, it can happen, that the test cases won't be recognized. In order to fix that, use the reload icon  in the top menu</p> <p></p> <p>To run the tests use the play icon  at the top.</p>"},{"location":"home/","title":"Home","text":"<p>The objective of SEEREP (SEmantic Environment REPresentation) is to store generated robot data and enable fast spatio-temporal-semantic queries over the data.</p>"},{"location":"home/#context","title":"Context","text":"<p>Autonomous robotic systems must be aware of their environment, in order to safely achieve their goal-oriented actions. Especially in unstructured and changing environments, a detailed model of the environment is required for reasoning and planning.</p> <p>The sensors of a robot provide spatial information via the robot's pose, temporal information is created by the point in time when a sensor is read. Semantic information always exists implicitly and can be made explicit by algorithms or manual labeling.</p> <p>Most existing environment representations focus on one or two of these information types, SEEREP is able to store all three. Thereby, SEEREP enables the robot to reason on a higher level and disambiguate sensor data based on the context.</p>"},{"location":"home/#core-features","title":"Core Features","text":"<ul> <li>Store robotic sensor data</li> <li>Images</li> <li>3D-Points</li> <li>Point Clouds</li> <li>TF</li> <li>Store analysis results alongside the corresponding sensor data</li> <li>Add (bounding box based) semantic annotations with confidences to the data</li> <li>Extend semantic annotations by object instances which are in multiple datasets</li> <li>Store information about an instance alongside the data</li> <li>Link 3d points to an instance to define the instance position</li> <li>Allow multiple categories of labels (e.g. a category per CNN). Thus, enabling easy evaluation and comparison of   multiple CNNs based on the same data</li> <li>Fast spatio-temporal-semantic queries with   gRPC.</li> <li>Storage of data generated by the robotic system:</li> <li>Offline on the robot (no or slow internet connection), currently in Progress         #89</li> <li>Online on a server-cluster, with         gRPC.</li> <li>Shifting computation loads away from the robot and into the cloud.</li> <li>Easily switch between Protocol Buffers   (PB) /   Flatbuffers (FB) as the messaging   format.</li> </ul>"},{"location":"home/#architecture","title":"Architecture","text":"<p>The following graphic provides a broad overview of SEEREPs components. The sensor data along with results from processing the data and annotations are stored in HDF5 files. SEEREP uses projects to group common information (e.g. a scanning campaign). The data can be saved locally on the robot or sent into the cloud with gRPC. Therefore, the computational load on the robot can be reduced and algorithms can fetch the data subset which they actually need.</p> <p></p> <p>A more detailed version, with all ROS packages and message types is available in the package overview.</p>"},{"location":"reference/packages/","title":"Package Overview","text":"<p>This page provides an overview of all the ROS-Packages used in SEEREP.</p>"},{"location":"reference/packages/#general-seerep-structure","title":"General SEEREP Structure","text":"<p>The general structure of SEEREP is schematically illustrated in the following graphic.</p> <p>SEEREP can be split into two parts, one of which runs on the robot (left box) and one which runs on a server clusters (right box). The communication is handled via gRPC and protocol-buffers (PB) or flatbuffers (FB).</p> <p></p>"},{"location":"reference/packages/#packages","title":"Packages","text":"<p>In the following, each package will be described in more detail.</p>"},{"location":"reference/packages/#seerep-hdf5","title":"seerep-hdf5","text":"<p>The\u00a0<code>seerep-hdf5</code>\u00a0unit provides access to the hdf5 files to store or retrieve data. The unit is split into three packages\u00a0<code>seerep-hdf5-core</code>,\u00a0<code>seerep-hdf5-pb</code>\u00a0and\u00a0<code>seerep-hdf5-fb</code>. This is to have a server-core which is independent of the message format, so that it's possible to easily switch between PB and FB or any other message format.</p> <ul> <li> <p>The main task for the <code>seerep-core</code> is to read UUIDs, bounding boxes (BB),   time/semantic information on provided indices from the hdf5-files. The only   write operation of the core is to create new hdf5-files. Due to the   independence of FB and PB, new communication-messages are added to seerep-msgs   (<code>seerep-msgs/core</code>).</p> </li> <li> <p><code>seerep-hdf5-pb</code> and <code>seerep-hdf5-fb</code> provide methods to read or write   point clouds, images and transformations from PB or FB  messages.</p> </li> </ul>"},{"location":"reference/packages/#seerep-srv","title":"seerep-srv","text":"<p>The <code>seerep-srv</code> is split into four parts <code>seerep-server</code>, <code>seerep-core</code> and <code>seerep-core-pb</code>, <code>seerep-core-fb</code>.</p> <ul> <li> <p>The <code>seerep-server</code> provides the top level interface for the SEEREP server   cluster, services which clients can be registered here. The server passes   request to the corresponding unit in the layer below (see graphic).</p> </li> <li> <p>The <code>seerep-core-pb</code> / <code>seerep-core-fb</code>  writes incoming PB / FB messages to   the hdf5 files. In case of a query the <code>seerep-core</code> is asked for the UUIDs of   the datasets which match the query parameters.</p> </li> </ul>"},{"location":"reference/packages/#seerep-msgs","title":"seerep-msgs","text":"<p>The <code>seerep-msgs</code> package defines all the PB, FB and core messages used in SEEREP.</p>"},{"location":"reference/packages/#seerep-ros","title":"seerep-ros","text":"<p><code>seerep-ros</code> provides three packages which run on the robot itself. The <code>seerep_ros_conversions_pb/fb</code> packages simply convert ROS messages to PB/FB and vice versa. The second package <code>seerep_ros_communication</code> is used to save sensor information like images and point clouds on the robot, or in case of a good internet connection to the remote server-cluster. Further, the robot is able to query the server for information to support his understanding of the environment and aid its navigation.</p> <ul> <li> <p>The <code>seerep_ros_communication\\client</code> is responsible for sending sensor   information directly to the remote server.</p> </li> <li> <p>The <code>seerep_ros_communication\\querier</code> is used to get information from the   remote server.</p> </li> <li> <p><code>seerep_ros_communication\\hdf5-dump</code> is used to save sensor information on a   hard drive which is located on the robot.</p> </li> </ul>"},{"location":"reference/packages/#seerep-com","title":"seerep-com","text":"<p><code>seerep-com</code> is used to define the gRPC services in PB and FB.</p>"},{"location":"reference/pytests-message-abstractions/","title":"Flatbuffers message abstractions","text":"<p>The message abstractions are a rather experimental way to more easily create test variations.</p> <p>Note: This API is subject to change in the future, as some functionality should get decoupled in a more elegant way.</p> <p>It is currently used to create variations for tests of <code>gRPC_fb_getInstances.py</code>. The tests can be found under test_gRPC_fb_getInstances.py.</p> <p>The idea is to provide default implementations for common datatypes, but still allow for modification of parts of that datatype. In some <code>flatbuffers</code> implementations there exists a API for mutability for that but unfortunately not for python and even when it would, it would still impose other problems.</p> <p>To tackle the problem, a wrapper is used where a set of enums, which corresponds to a datatype's components, can be given in order to assemble a datatype with those components \"activated\". Function pointers are used to define what should happen if a component is inactive (often just <code>None</code> is returned) and what should happen if a component is active.</p> <p>Datatype implementations for <code>Query</code> and <code>QueryInstance</code> and their abstraction model can be found here.</p>"},{"location":"reference/pytests-message-abstractions/#defining-new-datatypes-for-variation-testing","title":"Defining new datatypes for variation testing","text":"<p>First the datatype has to be defined as a class inheriting from FrozenEnum provided through datastructures.py, which is essentially a unmodifiable enum.</p> <p>This is done for the <code>FbQuery</code> datatype, which corresponding <code>flatbuffers</code> definition can be found here.</p> <pre><code>class EnumFbQuery(FrozenEnum):\n    POLYGON = auto()  # def: None\n    FULLY_ENCAPSULATED = auto()  # def: False\n    IN_MAP_FRAME = auto()  # def: True\n    TIMEINTERVAL = auto()  # def: None\n    LABEL = auto()  # def: None\n    SPARQL_QUERY = auto()  # def: None\n    ONTOLOGY_URI = auto()  # def: None\n    MUST_HAVE_ALL_LABELS = auto()  # def: False\n    PROJECTUUID = auto()  # def: None\n    INSTANCEUUID = auto()  # def: None\n    DATAUUID = auto()  # def: None\n    WITHOUTDATA = auto()  # def: False\n    MAX_NUM_DATA = auto()  # def: None\n    SORT_BY_TIME = auto()  # def: False\n</code></pre> <p>Then <code>FbQuery</code> inherits from <code>MsgsFb</code>, which itself is a template type defined in msgs_base.py.</p> <pre><code>class FbQuery(MsgsFb[Query.Query]):\n    def _set_enum_func_mapping(self) -&gt; Dict[EnumFbQuery, MsgsFunctions]:\n        return {\n            EnumFbQuery.POLYGON: MsgsFunctions(lambda: None, lambda: Dtypes.Fb.polygon2D(self.builder)),\n            EnumFbQuery.FULLY_ENCAPSULATED: MsgsFunctions(lambda: False, lambda: True),\n            EnumFbQuery.IN_MAP_FRAME: MsgsFunctions(lambda: True, lambda: False),\n            EnumFbQuery.TIMEINTERVAL: MsgsFunctions(lambda: None, lambda: Dtypes.Fb.time_interval(self.builder)),\n            EnumFbQuery.LABEL: MsgsFunctions(lambda: None, lambda: Dtypes.Fb.label_with_category(self.builder)),\n            EnumFbQuery.SPARQL_QUERY: MsgsFunctions(lambda: None, lambda: Dtypes.Fb.sparql_query(self.builder)),\n            EnumFbQuery.ONTOLOGY_URI: MsgsFunctions(lambda: None, lambda: Dtypes.Fb.ontology_uri(self.builder)),\n            EnumFbQuery.MUST_HAVE_ALL_LABELS: MsgsFunctions(lambda: False, lambda: True),\n            EnumFbQuery.PROJECTUUID: MsgsFunctions(\n                lambda: None, lambda: Dtypes.Fb.projectuuid(self.builder, self.channel)\n            ),\n            EnumFbQuery.INSTANCEUUID: MsgsFunctions(lambda: None, lambda: self.instanceuuid()),\n            EnumFbQuery.DATAUUID: MsgsFunctions(lambda: None, lambda: Dtypes.Fb.datauuid(self.builder, self.channel)),\n            EnumFbQuery.WITHOUTDATA: MsgsFunctions(lambda: False, lambda: True),\n            EnumFbQuery.MAX_NUM_DATA: MsgsFunctions(lambda: None, lambda: Dtypes.Fb.max_num_data()),\n            EnumFbQuery.SORT_BY_TIME: MsgsFunctions(lambda: False, lambda: True),\n        }\n\n    @expect_component(EnumFbQuery.PROJECTUUID)\n    def instanceuuid(self) -&gt; List[int]:\n        return Dtypes.Fb.intanceuuid(self.builder, self.channel, self.get_component(EnumFbQuery.PROJECTUUID))\n\n    @expect_component(EnumFbQuery.PROJECTUUID)\n    def datauuid(self) -&gt; List[int]:\n        return Dtypes.Fb.datauuid(self.builder, self.channel, self.get_component(EnumFbQuery.DATAUUID))\n\n    def _assemble_datatype_instance(self):\n        polygon = self.get_component(EnumFbQuery.POLYGON)\n        fully_encapsulated = self.get_component(EnumFbQuery.FULLY_ENCAPSULATED)\n        in_map_frame = self.get_component(EnumFbQuery.IN_MAP_FRAME)\n        timeinterval = self.get_component(EnumFbQuery.TIMEINTERVAL)\n        label = self.get_component(EnumFbQuery.LABEL)\n        must_have_all_labels = self.get_component(EnumFbQuery.MUST_HAVE_ALL_LABELS)\n        projectuuid = self.get_component(EnumFbQuery.PROJECTUUID)\n        instanceuuid = self.get_component(EnumFbQuery.INSTANCEUUID)\n        datauuid = self.get_component(EnumFbQuery.DATAUUID)\n        withoutdata = self.get_component(EnumFbQuery.WITHOUTDATA)\n        sort_by_time = self.get_component(EnumFbQuery.SORT_BY_TIME)\n\n        return fbh.createQuery(\n            self.builder,\n            timeinterval,\n            label,\n            must_have_all_labels,\n            projectuuid,\n            instanceuuid,\n            datauuid,\n            withoutdata,\n            polygon,\n            fully_encapsulated,\n            in_map_frame,\n            sort_by_time,\n        )\n</code></pre> <p>In <code>MsgsFb</code> <code>_set_enum_func_mapping()</code> is a abstractmethod which return type is a dictionary, which maps the enum types to <code>MsgsFunctions</code>. <code>MsgsFunction</code> itself is just a structure to wrap two function pointers. The first function pointer should be a pointer to the <code>default_function</code>, which gets called, if the component is not set to be active. The second function pointer is the one that gets called when the component is set active.</p> <p>On runtime it is checked if all elements of the enum are mapped. The functions are mostly mapped to default implementations for that specific component datatype. The default functions implementations can be inspected here at the bottom.</p> <p>The <code>@expect_component</code> decorator can be used to define dependencies between the component datatypes, e.g. for the <code>instanceuuid()</code> function to work, the <code>EnumFbQuery.PROJECTUUID</code> component must be set to active.</p> <p>Lastly the abstractmethod <code>_assemble_datatype_instance()</code> has to be implemented, in the function all of the wrapper managed components should be retrieved and the datatype should be built and returned. The base class makes sure that all the components at this point are set.</p>"},{"location":"reference/pytests-message-abstractions/#using-message-abstractions-for-testing","title":"Using message abstractions for testing","text":"<pre><code>def test_gRPC_getInstanceTypes(grpc_channel, project_setup):\n    _, proj_uuid = project_setup\n\n    ### check for instances on images\n    images_uuids, _, _ = send_imgs.send_labeled_images(proj_uuid, grpc_channel)\n    pcl_lst: List[PointCloud2.PointCloud2] = send_pcl.send_pointcloud(proj_uuid, grpc_channel)\n    img_uuid2point_map: Dict[str, PointStamped.PointStamped] = send_points.send_points(proj_uuid, grpc_channel)\n\n    # extract images ignore image uuids\n    images = [img[1] for img in images_uuids]\n\n    # retrieve the labelinstances of the bounding boxes\n    bbs_instances = []\n    for image in images:\n        for bb_cat in image.labels_bb:\n            for instance in bb_cat.boundingBox2DLabeled:\n                bbs_instances.append(instance.labelWithInstance.instanceUuid)\n\n    serv_man = ServiceManager(grpc_channel)\n\n    queryinst_builder = FbQueryInstance(grpc_channel, enum_types={EnumFbQueryInstance.DATATYPE})\n    queryinst_builder.set_active_function(EnumFbQueryInstance.DATATYPE, lambda: Datatype.Datatype.Image)\n    queryinst_builder.assemble_datatype_instance()\n\n    instance_uuidspp = serv_man.call_get_instances_fb(queryinst_builder.builder, queryinst_builder.datatype_instance)\n\n    bbs_instances = sorted(bbs_instances)\n\n    instance_uuids = get_sorted_uuids_per_proj(instance_uuidspp)\n\n    assert instance_uuids == bbs_instances\n</code></pre> <p>In this function all the possible datatypes with attached instances are tested (this is just a snippet of that particular function).</p> <p>The message abstractions are used by creating a object of <code>FbQueryInstance</code> first and setting the only active enum to <code>EnumFbQueryInstance.DATATYPE</code> using the <code>enum_types</code> variable on initialization, as this is the only relevant component to be modified for the test. In this case it would be relatively easy to test different sets of components together e.g. testing for interference when specific datatypes are set and while a polygon is used to restrict the relevant area.</p> <p>After that <code>set_active_function()</code> is used to set a different function pointer to the active component's function pointer. This essentially sets the second component of a <code>MsgsFunction</code> type in the dictionary returned by <code>_set_enum_func_mapping()</code>, which is discussed in the previous section.</p> <p>Lastly if a change to the dictionary has been done using <code>set_active_function()</code> or <code>set_mapped_functions()</code>, the <code>assemble_datatype_instance()</code> has to be called to reassemble the underlying datatype.</p> <p>Note: On creation of the instance the datatype is assembled automatically in it's constructor.</p> <p>Now the assembled datatype can be accessed using the property <code>queryinst_builder.datatype_instance</code> and the underlying flatbuffers builder can be accessed by using <code>queryinst_builder.builder</code> for further use, e.g. like in this case calling the service function <code>call_get_instances_fb()</code> using the ServiceManager.</p> <p>Note: The <code>MsgsBase</code> class provides it's own <code>ServiceManager</code> property for building components, but that one shouldn't be used as it could change in the future.</p> <p>Another snippet to highlight is the following where one of the components of the datatype itself is inheriting from <code>MsgsFb</code>.</p> <pre><code>def test_gRPC_getInstanceQueryTimeinterval(grpc_channel, project_setup):\n    _, proj_uuid = project_setup\n\n    serv_man = ServiceManager(grpc_channel)\n\n    # only send pictures to ease the testing process\n    images_uuids, _, _ = send_imgs.send_labeled_images(proj_uuid, grpc_channel)\n\n    # extract images ignore image uuids\n    images = [img[1] for img in images_uuids]\n\n    ### time interval tests\n    time_offset = 1000\n    cur_time = int(time.time())\n\n    min_time_ = cur_time - time_offset\n    max_time_ = cur_time + time_offset\n\n    query_builder = FbQuery(grpc_channel, enum_types={EnumFbQuery.TIMEINTERVAL})\n    queryinst_builder = FbQueryInstance(grpc_channel, enum_types={EnumFbQueryInstance.QUERY})\n\n    # test for time interval\n    min_timestamp = fbh.createTimeStamp(queryinst_builder.builder, min_time_, 0)\n    max_timestamp = fbh.createTimeStamp(queryinst_builder.builder, max_time_, 0)\n\n    img_time_interval = fbh.createTimeInterval(queryinst_builder.builder, min_timestamp, max_timestamp)\n\n    query_builder.set_active_function(EnumFbQuery.TIMEINTERVAL, lambda: img_time_interval)\n\n    queryinst_builder.set_active_function(EnumFbQueryInstance.QUERY, lambda: query_builder.datatype_instance)\n\n    query_builder.assemble_datatype_instance()\n\n    queryinst_builder.assemble_datatype_instance()\n\n    instance_uuids_intimeinterval = get_sorted_uuids_per_proj(\n        serv_man.call_get_instances_fb(queryinst_builder.builder, queryinst_builder.datatype_instance)\n    )\n\n    min_time_ = cur_time - 2 * time_offset\n    max_time_ = cur_time - time_offset\n\n    min_timestamp = fbh.createTimeStamp(queryinst_builder.builder, min_time_, 0)\n    max_timestamp = fbh.createTimeStamp(queryinst_builder.builder, max_time_, 0)\n\n    img_time_interval = fbh.createTimeInterval(queryinst_builder.builder, min_timestamp, max_timestamp)\n\n    query_builder.set_active_function(EnumFbQuery.TIMEINTERVAL, lambda: img_time_interval)\n\n    query_builder.assemble_datatype_instance()\n\n    queryinst_builder.assemble_datatype_instance()\n\n    instance_uuids_outtimeinterval = get_sorted_uuids_per_proj(\n        serv_man.call_get_instances_fb(queryinst_builder.builder, queryinst_builder.datatype_instance)\n    )\n\n    bbs_instances = get_instances_from_imgs(images)\n\n    assert len(instance_uuids_outtimeinterval) == 0\n    assert sorted(bbs_instances) == sorted(instance_uuids_intimeinterval)\n</code></pre> <p>Here <code>query_builder</code> is used to build the <code>Query.Query</code> datatype in order to supply that one to the <code>queryinst_builder</code> query component. It is important that <code>query_builder.assemble_datatype_instance()</code> is called before <code>queryinst_builder.assemble_datatype_instance()</code>, otherwise the changes by setting the active function on <code>query_builder</code> are not reflected in the <code>queryinst_builder.datatype_instance</code>.</p>"},{"location":"reference/pytests-message-abstractions/#inner-workings-of-the-msgsfb-and-msgsbase-classes","title":"Inner workings of the <code>MsgsFb</code> and <code>MsgsBase</code> classes","text":"<p>Meaning of Symbols and Notations in this diagram:</p> <ul> <li>Rectangular boxes: instance methods</li> <li>Ellipsis: instance variables</li> <li>Line arrows (with text): calls to methods or setting variables (with the help of those variables specified by the text)</li> <li>Line arrows with numbers: show the order in which things are done</li> <li>dotted arrows outgoing: Getter methods/properties</li> <li>dotted arrows incoming: Setter methods/properties</li> <li>red colored text: already used functionality in the examples above</li> <li>purple colored text: <code>@abstractmethod</code> also used above</li> <li>blue colored text: has a special meaning, is not mirrored exactly by the implementation</li> </ul> <p>Note: Some details are not shown like the validation methods for the given enum type. But they are not neccessary to understand the structure.</p> <p>First in the initialization phase variables (<code>_builder</code>, <code>_service_manager</code>, <code>_channel</code>, <code>_active_enums</code>) are set and managed by the <code>MsgsFb</code> instance, those are needed for the assembly of the datatype instance later. <code>_builder</code> is a simply a flatbuffers builder. <code>channel</code> is used to create <code>ServiceManager</code> instance and manage a <code>grpc_channel</code> type variable. At last <code>_active_enums</code> is a set of enum elements, which will be used to specify which component of the datatype is \"active\" (i.e. which component is set by the <code>active_function</code> of the <code>MsgsFunctions</code> class).</p> <p>After that the <code>_enum_func_mapping</code> variable is set by the <code>_set_enum_func_mapping()</code> function. This variable can also get manipulated by <code>set_active_function()</code> or <code>set_mapped_functions()</code>. Then <code>_assemble_components()</code> is called, which makes sure that the <code>_components</code> are set, i.e. the functions in the <code>_enum_func_mapping</code> are called and the components are set by those <code>default_functions</code> or those <code>active_functions</code>, if their corresponding enum is in the <code>_active_enums</code> set.</p> <p>Note: <code>_components</code> are implemented as multiple dynamically at runtime created instance variables with the name of the component specified by the enum element name.</p> <p>Finally the on the instance callable <code>assemble_datatype_instance()</code> method triggers a rebuild of the <code>_assembled_datatype_instance</code>, by first refreshing the components and then calling the <code>_assemble_datatype_instance()</code> method. The <code>assemble_datatype_instance()</code> method gets also called in the <code>__init__()</code> method, such that the message abstractions always try to guarantee a set <code>datatype_instance</code> variable.</p>"},{"location":"reference/python-helpers/","title":"Available Modules","text":""},{"location":"reference/python-helpers/#commonpy","title":"common.py","text":"<p>Contains common functions like <code>get_grpc_channel()</code> and some functions for passing into <code>boltons.iterutils.remap</code>.</p> <p>The source is located here.</p>"},{"location":"reference/python-helpers/#fb_helperpy","title":"fb_helper.py","text":"<p>This is a module provided through the seerep_grpc package. It provides functions to construct a subset of the SEEREP flatbuffers message in one function call. Most of the functions only return the component for further composition into another datatype. If the component itself should be serialized <code>builder.Finish()</code> as well as <code>builder.Output()</code> need to be called, on the from the function retrieved value.</p> <p>The source is located here.</p>"},{"location":"reference/python-helpers/#service_managerpy","title":"service_manager.py","text":"<p>Contains a class <code>ServiceManager</code> which when instantiated can be used to instantly call the services with the return values of the <code>fb_helper.py</code> functions, i.e. the <code>builder.Finish()</code> and <code>builder.Output()</code> calls are done in the <code>ServiceManager</code> methods. Example usage can be found in msg_abs/msgs.py , e.g.:</p> <pre><code>        @classmethod\n        def datauuid(cls, builder: Builder, channel: Channel) -&gt; List[int]:\n            query_fb = FbQuery(channel).datatype_instance\n            serv_man = ServiceManager(channel)\n            images = serv_man.call_get_images_fb(builder, query_fb)\n            points = serv_man.call_get_points_fb(builder, query_fb)\n            pcl2s = serv_man.call_get_pointcloud2_fb(builder, query_fb)\n\n            image_uuids = sorted([image.Header().UuidMsgs().decode() for image in images])\n            point_uuids = sorted([point.Header().UuidMsgs().decode() for point in points])\n            pcl2_uuids = sorted([pcl.Header().UuidMsgs().decode() for pcl in pcl2s])\n\n            # debugging\n            # print(\"images: \" + str(image_uuids))\n            # print(\"points: \" + str(point_uuids))\n            # print(\"pcls: \" + str(pcl2_uuids))\n\n            # fill up return list with every second uuid\n            ret_lst = [builder.CreateString(image_uuids[i]) for i in range(0, len(image_uuids), 2)]\n            ret_lst += [builder.CreateString(point_uuids[i]) for i in range(0, len(point_uuids), 2)]\n            ret_lst += [builder.CreateString(pcl2_uuids[i]) for i in range(0, len(pcl2_uuids), 2)]\n\n            return ret_lst\n</code></pre> <p>The source is located here.</p> <p>Note: This module is currently incomplete and contains only a subset of the available service calls.</p>"},{"location":"reference/python-helpers/#fb_to_dictpy","title":"fb_to_dict.py","text":""},{"location":"reference/python-helpers/#fb_flatc_dict","title":"fb_flatc_dict()","text":"<p>The <code>fb_flatc_dict</code> function can be used to convert serialized <code>flatbuffers</code> objects to a python dictionary. More information can be found by looking at the docstring:</p> <pre><code>    Converts a binary flatbuffers object to a python dictionary using it's IDL file.\n\n    This function should only be used for debugging or testing purposes, as it alleviates the advantage of flatbuffers\n    lessening the amount of copied data.\n\n    This implementation uses temporary files in /tmp for conversion.\n\n    Args:\n        fb_obj: The bytearray object as returned by builder.Output().\n        schema_file_name: The to `fb_obj` corresponding datatype in the `SchemaFileNames` format\n\n    Returns:\n        A python dictionary containing the objects attribute information.\n</code></pre>"},{"location":"reference/python-helpers/#catkin_find_schema_dir","title":"catkin_find_schema_dir()","text":"<p>Looking at the docstring should reveal everything to know about this function:</p> <pre><code>    Tries to find the schema directory on the system using `catkin locate`.\n\n    Args:\n        ros_pkg_name: The name of the ros package containing the relevant schema files\n        sub_dir: The name of the subdir of the package dir containing the relevant schema files\n\n    Returns:\n        The schema directory on the system if found.\n\n    Raises:\n        FileNotFoundError: If the path on the system is not present.\n        ChildProcessError: If `catkin locate` returns something on stderr or failed otherwise\n</code></pre>"},{"location":"reference/python-helpers/#schemafilenames","title":"SchemaFileNames","text":"<p>A enum type class, to map the available flatbuffers type schema file names. Only used as a type specifier for <code>fb_flatc_dict</code>.</p>"},{"location":"tutorials/images/","title":"Sending &amp; querying images","text":""},{"location":"tutorials/images/#sending-images","title":"Sending images","text":"<p>In this example we will send images with labeled bounding boxes as well as general labels to SEEREP.</p> <p>In order to save images, we need to mandatorily provide the intrinsics of the camera used to capture them. After the successfully saving the camera intrinsics, we need to provide the uuid of it along with the images. SEEREP will ensure that the Camera Intrinsics UUID provided with an image has a UUID stored against it.</p> <p>Additionally we add some coordinate transformations at the end.</p> <p>Source: examples/python/gRPC/images/gRPC_pb_sendLabeledImage.py</p> <pre><code>#!/usr/bin/env python3\n# NOTE: This file is referenced in the following mkdocs files:\n#   images.md\n# Any changes done in here will be reflected in there\nimport time\nimport uuid\nfrom typing import List, Optional, Tuple\n\nimport numpy as np\nfrom google.protobuf import empty_pb2\nfrom grpc import Channel\nfrom seerep.pb import boundingbox2d_labeled_pb2 as boundingbox2d_labeled\nfrom seerep.pb import (\n    boundingbox2d_labeled_with_category_pb2 as boundingbox2d_labeled_with_category,\n)\nfrom seerep.pb import camera_intrinsics_pb2 as cameraintrinsics\nfrom seerep.pb import camera_intrinsics_service_pb2_grpc as camintrinsics_service\nfrom seerep.pb import image_pb2 as image\nfrom seerep.pb import image_service_pb2_grpc as imageService\nfrom seerep.pb import label_with_instance_pb2 as labelWithInstance\nfrom seerep.pb import (\n    labels_with_instance_with_category_pb2 as labels_with_instance_with_category,\n)\nfrom seerep.pb import meta_operations_pb2_grpc as metaOperations\nfrom seerep.pb import projectCreation_pb2 as projectCreation\nfrom seerep.pb import tf_service_pb2_grpc as tfService\nfrom seerep.pb import transform_stamped_pb2 as tf\nfrom seerep.util.common import get_gRPC_channel\n\n\ndef send_labeled_images(\n    target_proj_uuid: Optional[str] = None, grpc_channel: Channel = get_gRPC_channel()\n) -&gt; Tuple[List[List[image.Image]], List[int], cameraintrinsics.CameraIntrinsics]:\n    \"\"\"sends test images via the given grpc_channel to the specified target project uuid\"\"\"\n\n    # 1. Get gRPC service objects\n    stub = imageService.ImageServiceStub(grpc_channel)\n    stubTf = tfService.TfServiceStub(grpc_channel)\n    stubMeta = metaOperations.MetaOperationsStub(grpc_channel)\n    stubCI = camintrinsics_service.CameraIntrinsicsServiceStub(grpc_channel)\n\n    # 2. Check if we have an existing test project (or target_proj_uuid is set), if not, one is created.\n    if target_proj_uuid is None:\n        # 3. Get all projects from the server\n        response = stubMeta.GetProjects(empty_pb2.Empty())\n        for project in response.projects:\n            print(project.name + \" \" + project.uuid)\n            if project.name == \"testproject\":\n                target_proj_uuid = project.uuid\n\n        if target_proj_uuid is None:\n            # 4. create a project\n            creation = projectCreation.ProjectCreation(name=\"testproject\", mapFrameId=\"map\")\n            projectCreated = stubMeta.CreateProject(creation)\n            target_proj_uuid = projectCreated.uuid\n\n    theTime = int(time.time())\n\n    #####\n    # A valid camera intrinsics UUID is needed here for succesful storage of Images\n    # Add new Camera Intrinsics with placeholder data\n\n    ciuuid = str(uuid.uuid4())\n\n    camin = cameraintrinsics.CameraIntrinsics()\n\n    camin.header.stamp.seconds = 4\n    camin.header.stamp.nanos = 3\n\n    camin.header.frame_id = \"camintrinsics\"\n\n    camin.header.uuid_project = target_proj_uuid\n    camin.header.uuid_msgs = ciuuid\n\n    camin.region_of_interest.x_offset = 2\n    camin.region_of_interest.y_offset = 1\n    camin.region_of_interest.height = 5\n    camin.region_of_interest.width = 4\n    camin.region_of_interest.do_rectify = 4\n\n    camin.height = 5\n    camin.width = 4\n\n    camin.distortion_model = \"plumb_bob\"\n\n    camin.distortion.extend(list(range(0, 3)))\n\n    camin.intrinsic_matrix.extend([3, 4, 5, 10, 7, 8, 9, 10, 11])\n    camin.rectification_matrix.extend([3, 4, 5, 6, 7, 8, 9, 10, 11])\n    camin.projection_matrix.extend([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n\n    camin.binning_x = 6\n    camin.binning_y = 7\n\n    camin.maximum_viewing_distance = 5\n\n    stubCI.TransferCameraIntrinsics(camin)\n\n    # 5. Create ten images\n    # for debugging and testing this example add all sent images to a list\n    sent_images_list: List[Tuple[str, image.Image]] = []\n\n    for n in range(10):\n        theImage = image.Image()\n\n        rgb = []\n        lim = 256  # 256 x 256 pixels\n        for i in range(lim):\n            for j in range(lim):\n                x = float(i) / lim\n                y = float(j) / lim\n                z = float(j) / lim\n                r = np.ubyte((x * 255.0 + n) % 255)\n                g = np.ubyte((y * 255.0 + n) % 255)\n                b = np.ubyte((z * 255.0 + n) % 255)\n                rgb.append(r)\n                rgb.append(g)\n                rgb.append(b)\n\n        # Add image meta-data\n        theImage.header.frame_id = \"camera\"\n        theImage.header.stamp.seconds = theTime + n\n        theImage.header.stamp.nanos = 0\n        theImage.header.uuid_project = target_proj_uuid\n        theImage.height = lim\n        theImage.width = lim\n        theImage.encoding = \"rgb8\"\n        theImage.step = 3 * lim\n        theImage.uuid_camera_intrinsics = ciuuid\n\n        # Add image data\n        theImage.data = bytes(rgb)\n\n        # 5. create categories for bounding boxes\n        for iCategory in range(0, 2):\n            bbCat = boundingbox2d_labeled_with_category.BoundingBox2DLabeledWithCategory()\n            bbCat.category = str(iCategory)\n            # 6. Create bounding boxes with labels with variations in the labels according to their index\n            bb = boundingbox2d_labeled.BoundingBox2DLabeled()\n            for i in range(0, 2):\n                bb.labelWithInstance.label.label = \"testlabel\" + str(i)\n                if n % 2 == 0:\n                    bb.labelWithInstance.label.label = f\"testlabel{i}_\"\n                if n % 4 == 0:\n                    bb.labelWithInstance.label.label = \"testlabel0\"\n\n                bb.labelWithInstance.label.confidence = i / 10.0\n                bb.labelWithInstance.instanceUuid = str(uuid.uuid4())\n                bb.boundingBox.center_point.x = 0.01 + i / 10\n                bb.boundingBox.center_point.y = 0.02 + i / 10\n                bb.boundingBox.spatial_extent.x = 0.03 + i / 10\n                bb.boundingBox.spatial_extent.y = 0.04 + i / 10\n                bbCat.boundingBox2DLabeled.append(bb)\n            theImage.labels_bb.append(bbCat)\n\n            # # 7. Add general labels to the image (in the same way as to the bounding boxes)\n            labelsCat = labels_with_instance_with_category.LabelsWithInstanceWithCategory()\n            labelsCat.category = str(iCategory)\n            for i in range(0, 2):\n                label = labelWithInstance.LabelWithInstance()\n                label.label.label = \"testlabelgeneral\" + str(i)\n                if n == 2:\n                    label.label.label = f\"testlabelgeneral{i}_\"\n                if n == 3:\n                    label.label.label = f\"testlabelgeneral{i}_\"\n\n                label.label.confidence = i / 10.0\n                # assuming that that the general labels are not instance related -&gt; no instance uuid\n                # label.instanceUuid = str(uuid.uuid4())\n                labelsCat.labelWithInstance.append(label)\n            theImage.labels_general.append(labelsCat)\n\n        # 8. Send image to the server\n        uuidImg = stub.TransferImage(theImage)\n\n        # also add them to the list\n        sent_images_list.append((uuidImg.message, theImage))\n\n    # a list for debugging and testing, if interpolated coordinates\n    # according to timestamp of the images and tfs are correct\n    tf_times: List[int] = []\n\n    # 8. Add coordinate transformations and send them to the server\n    theTf = tf.TransformStamped()\n    theTf.header.frame_id = \"map\"\n    theTf.header.stamp.seconds = theTime\n    theTf.header.uuid_project = target_proj_uuid\n    theTf.child_frame_id = \"camera\"\n    theTf.transform.translation.x = 1\n    theTf.transform.translation.y = 2\n    theTf.transform.translation.z = 3\n    theTf.transform.rotation.x = 0\n    theTf.transform.rotation.y = 0\n    theTf.transform.rotation.z = 0\n    theTf.transform.rotation.w = 1\n    stubTf.TransferTransformStamped(theTf)\n    tf_times.append(theTf.header.stamp.seconds)\n\n    theTf.header.stamp.seconds = theTime + 10\n    theTf.transform.translation.x = 100\n    theTf.transform.translation.y = 200\n    theTf.transform.translation.z = 300\n    stubTf.TransferTransformStamped(theTf)\n    tf_times.append(theTf.header.stamp.seconds)\n\n    # return sent data\n    return sent_images_list, tf_times, camin\n\n\nif __name__ == \"__main__\":\n    sent_image_ls_data, _, _ = send_labeled_images()\n    camera_intrinsics_allimgs = {intrins_uuid[1].uuid_camera_intrinsics for intrins_uuid in sent_image_ls_data}\n\n    # print statement to seperate the messages of the function\n    print()\n    print(f\"camera intrinsics will be saved against the uuid(s): {camera_intrinsics_allimgs}\")\n    img_uuids = [img[0] for img in sent_image_ls_data]\n    for i, img_uuid in enumerate(img_uuids):\n        print(f\"the uuid of the sent image number {i} is: {img_uuid}\")\n</code></pre> <p>Output:</p> <pre><code>testproject 28600b43-6385-4693-b617-c6209d9bde87\ntestproject 2292aa91-c369-4cb2-9de8-6987218fe268\n\ncamera intrinsics will be saved against the uuid(s): {'085a41c6-b81c-4a8e-a16c-fb71d99b0ffe'}\nthe uuid of the sent image number 0 is: 6821ea73-c9ca-45b3-97da-727ebe46cde5\nthe uuid of the sent image number 1 is: 1d5d2714-f9d3-45a5-b0fd-a45483057bd1\nthe uuid of the sent image number 2 is: 11251495-64d2-48be-8b3b-7ad06d360f02\nthe uuid of the sent image number 3 is: 2a2d8b62-3eb5-4bd8-aeeb-e8a4eab64322\nthe uuid of the sent image number 4 is: baadd923-b2ea-484c-9794-58788ce79980\nthe uuid of the sent image number 5 is: bdc82995-d827-41b3-9fd8-433e79dbced6\nthe uuid of the sent image number 6 is: 7678649c-39c9-4553-952e-cd93ed8ed675\nthe uuid of the sent image number 7 is: 1e5ff01d-ef2a-44e1-9af8-99496d9ecc2a\nthe uuid of the sent image number 8 is: c42b98ad-d92c-4b0c-9ea5-d6e6d4cff6e8\nthe uuid of the sent image number 9 is: b9619d15-5421-47db-a08b-ffb9f5cc8f3e\n</code></pre>"},{"location":"tutorials/images/#query-images","title":"Query images","text":"<p>Now we will query the previously send images with some criteria. Possible query parameters are:</p>"},{"location":"tutorials/images/#2d-polygon-spatial-query","title":"2D Polygon (spatial query)","text":"<p>Spatial queries in SEEREP are performed using a 2D polygon. This polygon should be simple (no more than 2 vertices on the same edge) and convex (no edges curving inward). This 2D polygon lies on a interval on the z-axis defined through a z-coordinate point and a height value. Queries are performed by forming an encompassing axis aligned bounding box from the polygon. This can lead to an AABB larger than the polygon and poses the potential problem of returning results to the user which are not fully inside the query polygon. That problem is resolved by providing a boolean variable called fullyEncapsulated`. If false, resultant polygons, which are partially inside the query polygon are also returned.</p>"},{"location":"tutorials/images/#a-time-interval-temporal-query","title":"A time interval (temporal query)","text":"<p>Temporal queries in SEEREP are performed using a time interval. When using image queries the stamp in the <code>header</code> of those images is used and when that time lies in the interval the image is returned as part of the response. The interval is closed.</p>"},{"location":"tutorials/images/#labels-semantic-query","title":"Labels (semantic query)","text":""},{"location":"tutorials/images/#projectuuids","title":"ProjectUuids","text":"<p>Only performs the query in these included projects specified by their uuids.</p>"},{"location":"tutorials/images/#withoutdata","title":"WithoutData","text":"<p>If the pixel data of the image should not be returned in order to save bandwith.</p>"},{"location":"tutorials/images/#inmapframe","title":"InMapFrame","text":"<p>Whether the query is done in the map frame. If not, the provided polygon for the spatial query will be transformed from the geodesic coordinates of the project into the map frame beforehand.</p>"},{"location":"tutorials/images/#example-code-for-querying-images","title":"Example code for querying images","text":"FlatbuffersProtocol Buffers <p>Source: examples/python/gRPC/images/gRPC_fb_queryImage.py</p> <pre><code>#!/usr/bin/env python3\n# NOTE: This file is referenced in the following mkdocs files:\n#   images.md\n# Any changes done in here will be reflected in there\nimport sys\nfrom typing import List, Optional\n\nimport flatbuffers\nfrom grpc import Channel\nfrom seerep.fb import Image\nfrom seerep.fb import image_service_grpc_fb as imageService\nfrom seerep.util.common import get_gRPC_channel\nfrom seerep.util.fb_helper import (\n    createLabelWithCategory,\n    createLabelWithConfidence,\n    createPoint2d,\n    createPolygon2D,\n    createQuery,\n    createTimeInterval,\n    createTimeStamp,\n    getProject,\n)\n\n\ndef query_images_raw(\n    target_proj_uuid: Optional[str] = None, grpc_channel: Channel = get_gRPC_channel()\n) -&gt; List[bytearray]:\n    builder = flatbuffers.Builder(1024)\n    if target_proj_uuid is None:\n        # 1. Get all projects from the server\n        target_proj_uuid = getProject(builder, grpc_channel, \"testproject\")\n        # 2. Check if the defined project exist, else return None\n        if target_proj_uuid is None:\n            print(\"valid project doesn't exist! Please execute gRPC_fb_addCameraIntrinsics.py beforehand.\")\n            return None\n\n    # 3. Get gRPC service object\n    stub = imageService.ImageServiceStub(grpc_channel)\n\n    # Create all necessary objects for the query\n    scale = 100\n    vertices = [\n        createPoint2d(builder, x * scale, y * scale) for x, y in [(-1.0, -1.0), (-1.0, 1.0), (1.0, 1.0), (1.0, -1.0)]\n    ]\n    polygon2d = createPolygon2D(builder, 700, -100, vertices)\n\n    # ruff: noqa: F841\n    timeMin = createTimeStamp(builder, 1610549273, 0)\n    timeMax = createTimeStamp(builder, 1938549273, 0)\n    timeInterval = createTimeInterval(builder, timeMin, timeMax)\n\n    projectUuids = [builder.CreateString(target_proj_uuid)]\n\n    # list of categories\n    category = [\"0\"]\n    # list of labels per category\n    labels = [\n        [\n            createLabelWithConfidence(builder, \"testlabel0\"),\n            createLabelWithConfidence(builder, \"testlabelgeneral0\"),\n        ]\n    ]\n    labelCategory = createLabelWithCategory(builder, category, labels)\n    dataUuids = [builder.CreateString(\"3e12e18d-2d53-40bc-a8af-c5cca3c3b248\")]\n    instanceUuids = [builder.CreateString(\"3e12e18d-2d53-40bc-a8af-c5cca3c3b248\")]\n\n    # 4. Create a query with parameters\n    # All parameters are optional!\n    # With all parameters set (especially with the data and instance uuids set) the result of the query will be empty.\n    # Set the query parameters to adequate values or remove them from the query creation\n    query = createQuery(\n        builder,\n        polygon2d=polygon2d,\n        # timeInterval=timeInterval,\n        # labels=labelCategory,\n        # mustHaveAllLabels=True,\n        projectUuids=projectUuids,\n        # instanceUuids=instanceUuids,\n        # dataUuids=dataUuids,\n        withoutData=True,\n        fullyEncapsulated=False,\n        inMapFrame=True,\n    )\n    builder.Finish(query)\n    buf = builder.Output()\n\n    # 5. Query the server for images matching the query and iterate over them\n    queried_images = stub.GetImage(bytes(buf))\n\n    return queried_images\n\n\ndef query_images(\n    target_proj_uuid: Optional[str] = None, grpc_channel: Channel = get_gRPC_channel()\n) -&gt; List[Image.Image]:\n    return [Image.Image.GetRootAs(img) for img in query_images_raw(target_proj_uuid, grpc_channel)]\n\n\nif __name__ == \"__main__\":\n    queried_images = query_images()\n    if queried_images is None:\n        print(\"no images were queried\")\n        sys.exit()\n    print(f\"count of images: {len(queried_images)}\")\n\n    for img in queried_images:\n        print(\"--------------------------------------------------------------------------------------------\")\n        print(f\"uuidmsg: {img.Header().UuidMsgs().decode('utf-8')}\")\n        print(f\"count of bounding box labels: {img.LabelsBbLength()}\")\n        if img.LabelsBbLength() &gt; 0:\n            print(\n                \"first label: \"\n                + img.LabelsBb(0).BoundingBox2dLabeled(0).LabelWithInstance().Label().Label().decode(\"utf-8\")\n                + \" ; confidence: \"\n                + str(img.LabelsBb(0).BoundingBox2dLabeled(0).LabelWithInstance().Label().Confidence())\n            )\n            print(\n                \"first bounding box (Xcenter,Ycenter,Xextent,Yextent, rotation): \"\n                + str(img.LabelsBb(0).BoundingBox2dLabeled(0).BoundingBox().CenterPoint().X())\n                + \" \"\n                + str(img.LabelsBb(0).BoundingBox2dLabeled(0).BoundingBox().CenterPoint().Y())\n                + \" \"\n                + str(img.LabelsBb(0).BoundingBox2dLabeled(0).BoundingBox().SpatialExtent().X())\n                + \" \"\n                + str(img.LabelsBb(0).BoundingBox2dLabeled(0).BoundingBox().SpatialExtent().Y())\n                + \" \"\n                + str(img.LabelsBb(0).BoundingBox2dLabeled(0).BoundingBox().Rotation())\n            )\n    print(\"--------------------------------------------------------------------------------------------\")\n</code></pre> <p>After sending the images, executing the query script results in the following output:</p> <pre><code>count of images: 6\n--------------------------------------------------------------------------------------------\nuuidmsg: 680128d1-5a86-457e-bd7f-be1d81371a30\ncount of bounding box labels: 2\nfirst label: testlabel0 ; confidence: 0.0\nfirst bounding box (Xcenter,Ycenter,Xextent,Yextent, rotation): 0.01 0.02 0.03 0.04 0.0\n--------------------------------------------------------------------------------------------\nuuidmsg: 6d6a9c09-3781-4e3e-a5df-948ab821b149\ncount of bounding box labels: 2\nfirst label: testlabel0 ; confidence: 0.0\nfirst bounding box (Xcenter,Ycenter,Xextent,Yextent, rotation): 0.01 0.02 0.03 0.04 0.0\n--------------------------------------------------------------------------------------------\nuuidmsg: 914273f7-96d3-453e-9a30-b4b411a81afe\ncount of bounding box labels: 2\nfirst label: testlabel0 ; confidence: 0.0\nfirst bounding box (Xcenter,Ycenter,Xextent,Yextent, rotation): 0.01 0.02 0.03 0.04 0.0\n--------------------------------------------------------------------------------------------\nuuidmsg: ad0db9ee-d0d8-46c2-9c13-518e29d3cc2b\ncount of bounding box labels: 2\nfirst label: testlabel0_ ; confidence: 0.0\nfirst bounding box (Xcenter,Ycenter,Xextent,Yextent, rotation): 0.01 0.02 0.03 0.04 0.0\n--------------------------------------------------------------------------------------------\nuuidmsg: b371b172-08d2-47c7-a750-db77149af897\ncount of bounding box labels: 2\nfirst label: testlabel0 ; confidence: 0.0\nfirst bounding box (Xcenter,Ycenter,Xextent,Yextent, rotation): 0.01 0.02 0.03 0.04 0.0\n--------------------------------------------------------------------------------------------\nuuidmsg: f1e755b2-fa6b-4cf0-a0f5-fc928be84850\ncount of bounding box labels: 2\nfirst label: testlabel0 ; confidence: 0.0\nfirst bounding box (Xcenter,Ycenter,Xextent,Yextent, rotation): 0.01 0.02 0.03 0.04 0.0\n--------------------------------------------------------------------------------------------\n</code></pre> <p>Source: examples/python/gRPC/images/gRPC_pb_queryImage.py</p> <pre><code>#!/usr/bin/env python3\n# NOTE: This file is referenced in the following mkdocs files:\n#   images.md\n# Any changes done in here will be reflected in there\nimport sys\nfrom typing import List, Optional\n\nfrom google.protobuf import empty_pb2\nfrom grpc import Channel\nfrom seerep.pb import image_pb2 as image\nfrom seerep.pb import image_service_pb2_grpc as imageService\nfrom seerep.pb import label_pb2\nfrom seerep.pb import labels_with_category_pb2 as labels_with_category\nfrom seerep.pb import meta_operations_pb2_grpc as metaOperations\nfrom seerep.pb import point2d_pb2 as point2d\nfrom seerep.pb import query_pb2 as query\nfrom seerep.util.common import get_gRPC_channel\n\n\ndef query_images(\n    target_project_uuid: Optional[str] = None,\n    grpc_channel: Channel = get_gRPC_channel(),\n) -&gt; List[image.Image]:\n    # 1. Get gRPC service objects\n    stub = imageService.ImageServiceStub(grpc_channel)\n    stubMeta = metaOperations.MetaOperationsStub(grpc_channel)\n\n    # 3. Check if we have an existing test project, if not, we stop here\n    if target_project_uuid is None:\n        # 2. Get all projects from the server\n        response = stubMeta.GetProjects(empty_pb2.Empty())\n        for project in response.projects:\n            print(project.name + \" \" + project.uuid + \"\\n\")\n            if project.name == \"testproject\":\n                target_project_uuid = project.uuid\n\n        if target_project_uuid is None:\n            print(\"No project with name 'testproject' found! Execute gRPC_pb_sendLabeledImage.py beforehand!\")\n            sys.exit()\n\n    # 4. Create a query with parameters\n    theQuery = query.Query()\n    theQuery.projectuuid.append(target_project_uuid)\n\n    theQuery.polygon.z = -200\n    theQuery.polygon.height = 800\n\n    theQuery.inMapFrame = True\n\n    scale = 150\n    vertices = [\n        point2d.Point2D(x=x, y=y) for x, y in [(-scale, -scale), (-scale, scale), (scale, scale), (scale, -scale)]\n    ]\n    theQuery.polygon.vertices.extend(vertices)\n\n    # since epoche\n    theQuery.timeinterval.time_min.seconds = 1638549273\n    theQuery.timeinterval.time_min.nanos = 0\n    theQuery.timeinterval.time_max.seconds = 1938549273\n    theQuery.timeinterval.time_max.nanos = 0\n\n    # labels\n    label = labels_with_category.LabelsWithCategory()\n    label.category = \"0\"\n    labelWithConfidence0 = label_pb2.Label()\n    labelWithConfidence0.label = \"testlabel0\"\n    labelWithConfidence1 = label_pb2.Label()\n    labelWithConfidence1.label = \"testlabel0_\"\n    label.labels.extend([labelWithConfidence0, labelWithConfidence1])\n    theQuery.labelsWithCategory.append(label)\n\n    # theQuery.inMapFrame = True\n    theQuery.fullyEncapsulated = False\n\n    # 5. Query the server for images matching the query and return them\n    return list(stub.GetImage(theQuery))\n\n\nif __name__ == \"__main__\":\n    queried_imgs = query_images()\n    print(f\"count of images {len(queried_imgs)}\")\n    for img in queried_imgs:\n        print(\n            f\"uuidmsg: {img.header.uuid_msgs}\"\n            + \"\\n\"\n            + f\"first label: {img.labels_bb[0].boundingBox2DLabeled[0].labelWithInstance.label.label}\"\n            + \"\\n\"\n            + f\"first label confidence: {img.labels_bb[0].boundingBox2DLabeled[0].labelWithInstance.label.confidence}\"\n            + \"\\n\"\n            + \"First bounding box (Xcenter,Ycenter,Xextent,Yextent):\"\n            + \" \"\n            + str(img.labels_bb[0].boundingBox2DLabeled[0].boundingBox.center_point.x)\n            + \" \"\n            + str(img.labels_bb[0].boundingBox2DLabeled[0].boundingBox.center_point.y)\n            + \" \"\n            + str(img.labels_bb[0].boundingBox2DLabeled[0].boundingBox.spatial_extent.x)\n            + \" \"\n            + str(img.labels_bb[0].boundingBox2DLabeled[0].boundingBox.spatial_extent.y)\n            + \"\\n\"\n        )\n</code></pre> <p>After sending the images, executing the query script results in the following output:</p> <pre><code>count of images 8\nuuidmsg: 680128d1-5a86-457e-bd7f-be1d81371a30\nfirst label: testlabel0\nfirst label confidence: 0.0\nFirst bounding box (Xcenter,Ycenter,Xextent,Yextent): 0.01 0.02 0.03 0.04\n\nuuidmsg: 6d6a9c09-3781-4e3e-a5df-948ab821b149\nfirst label: testlabel0\nfirst label confidence: 0.0\nFirst bounding box (Xcenter,Ycenter,Xextent,Yextent): 0.01 0.02 0.03 0.04\n\nuuidmsg: 914273f7-96d3-453e-9a30-b4b411a81afe\nfirst label: testlabel0\nfirst label confidence: 0.0\nFirst bounding box (Xcenter,Ycenter,Xextent,Yextent): 0.01 0.02 0.03 0.04\n\nuuidmsg: ad0db9ee-d0d8-46c2-9c13-518e29d3cc2b\nfirst label: testlabel0_\nfirst label confidence: 0.0\nFirst bounding box (Xcenter,Ycenter,Xextent,Yextent): 0.01 0.02 0.03 0.04\n\nuuidmsg: b371b172-08d2-47c7-a750-db77149af897\nfirst label: testlabel0\nfirst label confidence: 0.0\nFirst bounding box (Xcenter,Ycenter,Xextent,Yextent): 0.01 0.02 0.03 0.04\n\nuuidmsg: b6abe511-ba53-4782-82d3-53fb80887754\nfirst label: testlabel0\nfirst label confidence: 0.0\nFirst bounding box (Xcenter,Ycenter,Xextent,Yextent): 0.01 0.02 0.03 0.04\n\nuuidmsg: cf1d977f-5356-4edc-a02b-e4b454547f63\nfirst label: testlabel0_\nfirst label confidence: 0.0\nFirst bounding box (Xcenter,Ycenter,Xextent,Yextent): 0.01 0.02 0.03 0.04\n\nuuidmsg: f1e755b2-fa6b-4cf0-a0f5-fc928be84850\nfirst label: testlabel0\nfirst label confidence: 0.0\nFirst bounding box (Xcenter,Ycenter,Xextent,Yextent): 0.01 0.02 0.03 0.04\n</code></pre>"},{"location":"tutorials/overview/","title":"Tutorials Overviews","text":"<p>The tutorials provide a starting point on how you can use SEEREP. Currently, the following topics are covered:</p> <ul> <li>Creating and retrieving projects</li> <li>Sending and querying images</li> <li>Writing python examples</li> <li>Writing python integration tests</li> </ul> <p>Before running any of the tutorials, make sure that you have a  running SEEREP instance available.</p> <p>If you're not familiar with flatbuffers, it is highly recommended to look at the tutorial first. Click on the python radio button to see the language specific tutorial.</p>"},{"location":"tutorials/overview/#local-instance","title":"Local Instance","text":"<p>To start SEEREP locally use <code>STRG+SHIFT+D</code> to open the Run &amp; Debug Menu in Vs-Code, select <code>seerep server</code> and press run. Now a terminal should open and print the following info messages:</p> <pre><code>Starting seerep server\n[2022-08-01 13:50:35.765427]&lt;info&gt;: The used logging folder is: /seerep/seerep-data/log/\n[2022-08-01 13:50:35.765575]&lt;info&gt;: The used data folder is: /seerep/seerep-data/\n[2022-08-01 13:50:35.765801]&lt;info&gt;: add the protobuf gRPC services...\n[2022-08-01 13:50:35.765860]&lt;info&gt;: add the flatbuffer gRPC services...\n[2022-08-01 13:50:35.767787]&lt;info&gt;: serving gRPC Server on \"[::]:9090\"...\n</code></pre>"},{"location":"tutorials/projects/","title":"Creating &amp; Retrieving Projects","text":""},{"location":"tutorials/projects/#creating-new-projects","title":"Creating new projects","text":"<p>New projects for new data can be created in the following way:</p> <p>Source: examples/gRPC/meta/gRPC_pb_createProject.py</p> <pre><code>#!/usr/bin/env python3\n# NOTE: This file is referenced in the following mkdocs files:\n#   projects.md\n# Any changes done in here will be reflected in there\nfrom typing import Tuple\n\nfrom grpc import Channel\nfrom seerep.pb import meta_operations_pb2_grpc as metaOperations\nfrom seerep.pb import projectCreation_pb2\nfrom seerep.util.common import get_gRPC_channel\n\n\ndef create_project(grpc_channel: Channel = get_gRPC_channel()) -&gt; Tuple[str, str]:\n    stub = metaOperations.MetaOperationsStub(grpc_channel)\n    response = stub.CreateProject(projectCreation_pb2.ProjectCreation(name=\"testproject\", mapFrameId=\"map\"))\n\n    return response.name, response.uuid\n\n\nif __name__ == \"__main__\":\n    ret = create_project()\n    print(\"The new project on the server is (name/uuid):\")\n    print(\"\\t\" + ret[0] + \" \" + ret[1])\n</code></pre> <p>Output:</p> <pre><code>The new project on the server is (name/uuid):\n        testproject eff47bc9-c39e-430e-8153-88e0eab65768\n</code></pre>"},{"location":"tutorials/projects/#retrieving-projects","title":"Retrieving projects","text":"<p>After we created two projects, we can query them. Currently the name doesn't have to be unique.</p> FlatbuffersProtocol Buffers <p>Source: examples/gRPC/meta/gRPC_fb_getProjects.py</p> <pre><code>#!/usr/bin/env python3\n# NOTE: This file is referenced in the following mkdocs files:\n#   projects.md\n# Any changes done in here will be reflected in there\nfrom typing import List\n\nimport flatbuffers\nfrom grpc import Channel\nfrom seerep.fb import Empty, ProjectInfo, ProjectInfos\nfrom seerep.fb import meta_operations_grpc_fb as metaOperations\nfrom seerep.util.common import get_gRPC_channel\n\n\ndef get_projects_raw(\n    grpc_channel: Channel = get_gRPC_channel(),\n) -&gt; bytearray:\n    \"\"\"\n    Returns: bytearray of type ProjectInfos\n    \"\"\"\n    stub = metaOperations.MetaOperationsStub(grpc_channel)\n\n    builder = flatbuffers.Builder(1024)\n    Empty.Start(builder)\n    emptyMsg = Empty.End(builder)\n    builder.Finish(emptyMsg)\n    buf = builder.Output()\n\n    responseBuf = stub.GetProjects(bytes(buf))\n    return responseBuf\n\n\ndef get_projects(\n    grpc_channel: Channel = get_gRPC_channel(),\n) -&gt; ProjectInfos.ProjectInfos:\n    return ProjectInfos.ProjectInfos.GetRootAs(get_projects_raw(grpc_channel))\n\n\nif __name__ == \"__main__\":\n    response = get_projects()\n\n    projects_list: List[ProjectInfo.ProjectInfo] = []\n\n    for i in range(response.ProjectsLength()):\n        projects_list.append(response.Projects(i))\n\n    print(\"The server has the following projects (name/uuid):\")\n    for project in projects_list:\n        print(\"\\t\" + project.Name().decode(\"utf-8\") + \" \" + project.Uuid().decode(\"utf-8\"))\n</code></pre> <p>Output:</p> <pre><code>The server has the following projects (name/uuid):\n    testproject 5c1ed18e-9180-40e1-a79b-594f8266d898\n    testproject 9fc3011f-4a3c-400e-9170-06973a6fb395\n</code></pre> <p>Source: examples/gRPC/meta/gRPC_pb_getProjects.py</p> <pre><code>#!/usr/bin/env python3\n# NOTE: This file is referenced in the following mkdocs files:\n#   projects.md\n# Any changes done in here will be reflected in there\nfrom typing import List, Tuple\n\nfrom google.protobuf import empty_pb2\nfrom grpc import Channel\nfrom seerep.pb import meta_operations_pb2_grpc as metaOperations\nfrom seerep.util.common import get_gRPC_channel\n\n\ndef get_projects(grpc_channel: Channel = get_gRPC_channel()) -&gt; List[Tuple[str, str]]:\n    stub = metaOperations.MetaOperationsStub(grpc_channel)\n\n    response = stub.GetProjects(empty_pb2.Empty())\n\n    projects_list: List[Tuple[str, str]] = []\n    print(\"The server has the following projects (name/uuid):\")\n\n    for projectinfo in response.projects:\n        projects_list.append((projectinfo.name, projectinfo.uuid))\n\n    return projects_list\n\n\nif __name__ == \"__main__\":\n    project_list = get_projects()\n    for proj in project_list:\n        print(\"\\t\" + proj[0] + \" \" + proj[1])\n</code></pre> <p>Output:</p> <pre><code>The Server has the following projects (name/uuid):\n    testproject 5c1ed18e-9180-40e1-a79b-594f8266d898\n    testproject 9fc3011f-4a3c-400e-9170-06973a6fb395\n</code></pre>"},{"location":"tutorials/writing-python-examples/","title":"Writing examples for the SEEREP API","text":"<p>To write a example it is a good idea to refer to already written ones. The focus in this documentation lies on flatbuffers type messages, because of the potential deprecation of protobuf in the project. All protobuf functionality can be replicated using flatbuffers, and flatbuffers should be used instead.</p> <p>In this case the example gRPC_fb_addBoundingBox.py will be reviewed. Service type definitions for all available flatbuffers type services can be found here. Type definitions of all flatbuffers types can be found here.</p>"},{"location":"tutorials/writing-python-examples/#the-code","title":"The code","text":"<pre><code>import sys\nimport uuid\nfrom typing import List, Optional, Tuple\n\nimport flatbuffers\nimport numpy as np\nfrom grpc import Channel\nfrom seerep.fb import BoundingBoxes2DLabeledStamped, Image, ProjectInfos\nfrom seerep.fb import image_service_grpc_fb as imageService\nfrom seerep.fb import meta_operations_grpc_fb as meta_ops\nfrom seerep.util.common import get_gRPC_channel\nfrom seerep.util.fb_helper import (\n    createBoundingBox2dLabeledStamped,\n    createBoundingBox2DLabeledWithCategory,\n    createBoundingBoxes2d,\n    createBoundingBoxes2dLabeled,\n    createEmpty,\n    createHeader,\n    createLabelsWithInstance,\n    createPoint2d,\n    createQuery,\n)\n</code></pre> <p>First some of the modules to interact with the servers services will be highlighted. <code>seerep.fb</code> contains all python interfaces for the SEEREP services as well as the Message types. sereep.util.fb_helper contains helper functions related to flatbuffers, for instance functions to create a message type directly.</p>"},{"location":"tutorials/writing-python-examples/#interaction-with-seerep-services-and-handling-the-data","title":"Interaction with SEEREP services and handling the data","text":"<pre><code>def add_bb_raw(\n    target_proj_uuid: Optional[str] = None, grpc_channel: Channel = get_gRPC_channel()\n) -&gt; List[Tuple[str, bytearray]]:\n</code></pre> <p>The interaction functionality is contained within this function. With the function definition, an option should be given to specify a target project, if the message type allows setting it. Additionally the <code>grpc_channel</code> should be a parameter in order to be able to target servers other than <code>localhost:9090</code>. Both options are useful for testing later. More parameters can be added optionally, if needed for the test cases.</p> <pre><code>    stubMeta = meta_ops.MetaOperationsStub(grpc_channel)\n\n    # 3. Check if we have an existing test project, if not, one is created.\n    if target_proj_uuid is None:\n        # 2. Get all projects from the server\n        response = ProjectInfos.ProjectInfos.GetRootAs(\n            stubMeta.GetProjects(bytes(createEmpty(flatbuffers.Builder(1024))))\n        )\n        for i in range(response.ProjectsLength()):\n            proj_name = response.Projects(i).Name().decode()\n            proj_uuid = response.Projects(i).Uuid().decode()\n            print(proj_name + \" \" + proj_uuid)\n            if proj_name == \"testproject\":\n                target_proj_uuid = proj_uuid\n\n        if target_proj_uuid is None:\n            print(\"Please create a project with labeled images using gRPC_pb_sendLabeledImage.py first.\")\n            sys.exit()\n</code></pre> <p>At first, if <code>target_proj_uuid</code> is not set, the <code>MetaOperationsStub</code> utilizing flatbuffers gRPC communication with the SEEREP server is used to retrieve a list of all available projects of that server (specifically in the form of project_infos.fbs ) and <code>target_proj_uuid</code> is set to the uuid of the first project with the name <code>testproject</code> on that list.</p> <pre><code>    stub = imageService.ImageServiceStub(grpc_channel)\n\n    builder = flatbuffers.Builder(1024)\n    query = createQuery(builder, projectUuids=[builder.CreateString(target_proj_uuid)], withoutData=True)\n    builder.Finish(query)\n    buf = builder.Output()\n\n    response_ls: List = list(stub.GetImage(bytes(buf)))\n    if not response_ls:\n        print(\"No images found. Please create a project with labeled images using gRPC_pb_sendLabeledImage.py first.\")\n        sys.exit()\n</code></pre> <p>Following on the code requests all images from the project with the <code>uuid</code> of <code>target_proj_uuid</code> using the <code>ImageServiceStub</code>. The service definition looks as follows:</p> <pre><code>include \"image.fbs\";\ninclude \"query.fbs\";\ninclude \"boundingboxes2d_labeled_stamped.fbs\";\n\ninclude \"server_response.fbs\";\n\nnamespace seerep.fb;\n\nrpc_service ImageService {\n  GetImage(seerep.fb.Query):seerep.fb.Image (streaming: \"server\");\n  TransferImage(seerep.fb.Image):seerep.fb.ServerResponse  (streaming: \"client\");\n  AddBoundingBoxes2dLabeled(seerep.fb.BoundingBoxes2DLabeledStamped):seerep.fb.ServerResponse   (streaming: \"client\");\n}\n</code></pre> <p><code>GetImage()</code> takes a argument of type seerep.fb.Query, a more generic build query type for use in various services in SEEREP, in it's serialized form and returns data of type seerep.fb.Image from the server.</p> <pre><code>    msgToSend = []\n    bb_list: List[Tuple[str, bytearray]] = []\n\n    for responseBuf in response_ls:\n        response = Image.Image.GetRootAs(responseBuf)\n\n        img_uuid = response.Header().UuidMsgs().decode(\"utf-8\")\n        header = createHeader(\n            builder,\n            projectUuid=response.Header().UuidProject().decode(\"utf-8\"),\n            msgUuid=img_uuid,\n        )\n\n        # create bounding box labels\n        x1, y1 = np.random.rand(), np.random.rand()\n        x2, y2 = np.random.rand(), np.random.rand()\n\n        boundingBoxes = createBoundingBoxes2d(\n            builder,\n            [createPoint2d(builder, x1, y1) for _ in range(NUM_BB_LABELS)],\n            [createPoint2d(builder, x2, y2) for _ in range(NUM_BB_LABELS)],\n        )\n        labelWithInstances = createLabelsWithInstance(\n            builder,\n            [\"BoundingBoxLabel\" + str(i) for i in range(NUM_BB_LABELS)],\n            [1.0 / (i + 0.1) for i in range(NUM_BB_LABELS)],\n            [str(uuid.uuid4()) for _ in range(NUM_BB_LABELS)],\n        )\n        labelsBb = createBoundingBoxes2dLabeled(builder, labelWithInstances, boundingBoxes)\n\n        boundingBox2DLabeledWithCategory = createBoundingBox2DLabeledWithCategory(\n            builder, builder.CreateString(\"laterAddedBB\"), labelsBb\n        )\n\n        labelsBbVector = createBoundingBox2dLabeledStamped(builder, header, [boundingBox2DLabeledWithCategory])\n        builder.Finish(labelsBbVector)\n        buf = builder.Output()\n\n        bb_list.append(\n            (\n                img_uuid,\n                buf,\n            )\n        )\n\n        msgToSend.append(bytes(buf))\n</code></pre> <p>This code builds a list of BoundingBoxes adding some sample data into the components of each BoundingBox. At the beginning two lists are defined <code>msgToSend</code> is a list containing the serialized BoundingBoxes and <code>bb_list</code> is a list containing mappings where each image uuid is mapped to it's added BoundingBoxes. After that the returned images from the query before are iterated. Next BoundingBoxes are created and their joint <code>header</code> uuids are set to the appropriate <code>project_uuid</code> and <code>msg_uuid</code> to match that specific image. At the end the BoundingBoxes are serialized and added to the lists.</p> <p>The type definition of BoundingBoxes2DLabeledStamped looks as follows:</p> <pre><code>include \"header.fbs\";\ninclude \"boundingbox2d_labeled_with_category.fbs\";\n\nnamespace seerep.fb;\n\ntable BoundingBoxes2DLabeledStamped {\n  header:seerep.fb.Header;\n  labels_bb:[seerep.fb.BoundingBox2DLabeledWithCategory];\n}\n\nroot_type BoundingBoxes2DLabeledStamped;\n</code></pre> <pre><code>    stub.AddBoundingBoxes2dLabeled(iter(msgToSend))\n    return bb_list\n</code></pre> <p>Lastly the service is called, the BoundingBoxes are send to the SEEREP server and the list with the mappings is returned for further use. Note that the flatbuffers objects are not returned in their deserialized state as the function <code>fb_flatc_dict</code> defined in here makes use of that state.</p>"},{"location":"tutorials/writing-python-examples/#wrapping-the-raw-function","title":"Wrapping the raw function","text":"<pre><code>def add_bb(\n    target_proj_uuid: Optional[str] = None, grpc_channel: Channel = get_gRPC_channel()\n) -&gt; List[Tuple[str, BoundingBoxes2DLabeledStamped.BoundingBoxes2DLabeledStamped]]:\n    return [\n        (img_uuid, BoundingBoxes2DLabeledStamped.BoundingBoxes2DLabeledStamped.GetRootAs(bbbuf))\n        for img_uuid, bbbuf in add_bb_raw(target_proj_uuid, grpc_channel)\n    ]\n</code></pre> <p>This function is essentially just a wrapper for <code>add_bb_raw()</code> to return the deserialized objects to be accessed through their regular flatbuffers interfaces (in this case of type <code>BoundingBoxes2DLabeledStamped.BoundingBoxes2DLabeledStamped</code>).</p>"},{"location":"tutorials/writing-python-examples/#allow-for-independent-execution-of-the-script","title":"Allow for independent execution of the script","text":"<pre><code>if __name__ == \"__main__\":\n    bb_list = add_bb()\n    for img_uuid, bbs_img in bb_list:\n        print(\n            f\"Added bounding boxes to image with uuid {img_uuid}, with the following center points and spatial extents:\"\n        )\n        print(\"[center_point(x, y) | spatial_extent(x, y)]\")\n        for bbs_wcat in [bbs_img.LabelsBb(idx) for idx in range(bbs_img.LabelsBbLength())]:\n            for bb in [\n                bbs_wcat.BoundingBox2dLabeled(idx).BoundingBox() for idx in range(bbs_wcat.BoundingBox2dLabeledLength())\n            ]:\n                print(\n                    f\"[({bb.CenterPoint().X()}, {bb.CenterPoint().Y()}) | \\\n                    ({bb.SpatialExtent().X()}, {bb.SpatialExtent().Y()})]\"\n                )\n        print()\n</code></pre> <p>The last part can execute the script independently and targets the server at the default address, which is <code>localhost:9090</code>. On successful execution a subset of the sent data based on the returned mapping is printed.</p>"},{"location":"tutorials/writing-python-examples/#some-important-considerations","title":"Some important considerations","text":"<p>To conclude for most of the examples it is best practice to follow this structure, namely first having a function which returns the serialized data, then wrapping that function to return the deserialized variant and at the end the <code>if __name__ == \"__main__\"</code> part of the script, such that the script can be executed independently. Of course functionality can be outsourced into other functions, when it makes sense. This structure eases the process of writing tests later on (see writing-tests.md), especially when <code>fb_flatc_dict</code> should be utilized.</p>"},{"location":"tutorials/writing-python-tests/","title":"Writing integration tests for example pyscripts","text":"<p>Before a test is written it makes sense to understand how a example is structured. For this see writing-examples.md as a introduction. How tests can be structured will be demonstrated on the already created <code>test_gRPC_fb_addBoundingBox</code> test found here.</p> <p>As the testing framework for python pytest is used.</p>"},{"location":"tutorials/writing-python-tests/#the-code","title":"The code","text":"<pre><code>from typing import List\n\nimport flatbuffers\nfrom grpc import Channel\nfrom gRPC.images import gRPC_fb_addBoundingBox as add_bb\nfrom gRPC.images import gRPC_pb_sendLabeledImage as add_img\nfrom seerep.fb import image_service_grpc_fb as imageService\nfrom seerep.util.fb_helper import createQuery\nfrom seerep.util.fb_to_dict import SchemaFileNames, fb_flatc_dict\n</code></pre> <p>For the imported modules, note that the examples themselves are imported to be used in the tests. Furthermore helper functions from <code>seerep.util.fb_helper</code>, as well as <code>fb_flatc_dict</code> are imported.</p> <pre><code>def get_imgs(target_proj_uuid: str, grpc_channel: Channel) -&gt; List:\n    builder = flatbuffers.Builder(1024)\n    stub = imageService.ImageServiceStub(grpc_channel)\n    query = createQuery(builder, projectUuids=[builder.CreateString(target_proj_uuid)], withoutData=True)\n    builder.Finish(query)\n    buf = builder.Output()\n    response_ls: List = list(stub.GetImage(bytes(buf)))\n\n    return [fb_flatc_dict(buf, SchemaFileNames.IMAGE) for buf in response_ls]\n</code></pre> <p>This is a helper function to retrieve all images the targeted project on the targeted server has. At the end with the service call <code>GetImage()</code> the images are returned in a list of bytearray objects, which on the return line are converted to a python dictionary with the help of the <code>SchemaFileNames</code> enum. <code>SchemaFileNames</code> contains references to the file names of the datatypes of all the SEEREP flatbuffers types, this is required for the <code>flatc</code> compiler to know how to decode the object.</p> <pre><code>def test_addBoundingBox(grpc_channel, project_setup):\n    proj_name, proj_uuid = project_setup\n\n    # send labeled images to the server for preparation\n    add_img.send_labeled_images(target_proj_uuid=proj_uuid, grpc_channel=grpc_channel)\n\n    sent_bb = add_bb.add_bb_raw(target_proj_uuid=proj_uuid, grpc_channel=grpc_channel)\n\n    assert sent_bb is not None\n\n    # use a regular query to query the images from the server to check if the bounding box is the same\n    all_imgs = get_imgs(proj_uuid, grpc_channel)\n\n    for bb_img_uuid, bbs_img in sent_bb:\n        img_bb = [img for img in all_imgs if img[\"header\"][\"uuid_msgs\"] == bb_img_uuid][0]\n\n        # iterate through all categories of the image\n        filtered_bbs = [bb for bb in img_bb[\"labels_bb\"] if bb[\"category\"] == \"laterAddedBB\"]\n\n        sent_bbs = fb_flatc_dict(bbs_img, SchemaFileNames.BOUNDINGBOXES2D_LABELED_STAMPED)[\"labels_bb\"]\n\n        assert len(filtered_bbs) == len(sent_bbs)\n\n        for bb_cat in filtered_bbs:\n            assert bb_cat in sent_bbs\n</code></pre> <p>Next up the test function is defined and uses the fixture <code>grpc_channel</code>, which spins the test server up, creates a channel to that server and makes sure that the server is terminated after testing is done. The fixture <code>project_setup</code> creates a test project on the server and deletes that after the testing function using SEEREP server calls. Implementations of both fixtures can be found here.</p> <p>After that the <code>project_uuid</code> of the created project is retrieved and used for the different calls to the example functions. To attach new BoundingBoxes to images, it has to be ensured that images are present. This is done by utilizing the gRPC_pb_sendLabeledImage example. Then the BoundingBoxes example can be used to add BoundingBoxes to those images.</p> <p>Following on the BoundingBoxes returned by <code>add_bb_raw()</code> are tested and compared against those now persisting on the server. <code>get_imgs</code> retrieves all the images from the server, each mapping of image <code>uuid</code> to BoundingBoxes is iterated and in the list of all images the image, which matches the image <code>uuid</code> of the mapping, is inspected further. Only the BoundingBoxes with the category <code>laterAddedBB</code> are relevant and therefore filtered. Lastly the sent BoundingBoxes are converted to python dictionaries and compared for matching with the filtered image attached BoundingBoxes.</p>"},{"location":"tutorials/writing-python-tests/#tips-to-ease-development","title":"Tips to ease development","text":"<ul> <li><code>fb_flatc_dict()</code> in conjunction with <code>pytest -s</code> command is a good option for debugging tests, as the dictionary and therefore the objects data contents can be printed that way.</li> <li>If a recursive operation has to be applied to a dictionary <code>boltons</code> remap() function can be used, like in test_gRPC_fb_createGeodeticCoordProject.py.</li> <li>If a test should contain a lot of variations in the components of a datatype a look here could simplify things</li> </ul>"}]}